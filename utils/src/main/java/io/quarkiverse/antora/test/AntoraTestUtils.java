package io.quarkiverse.antora.test;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.function.Predicate;
import java.util.stream.Stream;

import org.jboss.logging.Logger;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;

import io.quarkiverse.antora.WebBundlerResourceHandler;
import io.quarkiverse.antora.test.LinkValidator.ValidationResult;

/**
 * Utilities for testing the generated Antora sites.
 */
public class AntoraTestUtils {

    private static final Logger log = Logger.getLogger(AntoraTestUtils.class);

    private AntoraTestUtils() {
    }

    /**
     * @return a closeable {@link Stream} of HTML files generated by Antora
     */
    public static Stream<Path> htmlResources() {
        String basePath = WebBundlerResourceHandler.META_INF_ANTORA;
        try {
            URI uri = Thread.currentThread().getContextClassLoader().getResource(basePath).toURI();
            if ("jar".equals(uri.getScheme())) {
                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, java.util.Collections.emptyMap())) {
                    Path pathInJar = fileSystem.getPath(basePath);
                    return listFiles(pathInJar);
                } catch (IOException e) {
                    throw new RuntimeException("Could not create a file system at " + uri, e);
                }
            } else {
                return listFiles(Paths.get(uri));
            }
        } catch (URISyntaxException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * @return a {@link Stream} of URIs with {@link Path}s where they occur
     */
    public static Stream<Map.Entry<String, Set<Path>>> externalLinks() {
        final Map<String, Set<Path>> result = new TreeMap<>();
        try (Stream<Path> paths = AntoraTestUtils.htmlResources()) {
            paths.forEach(p -> {
                try {
                    final Document doc = Jsoup.parse(p);
                    for (Element link : doc.select("a[href]")) {
                        final String linkHref = link.attr("href");
                        if ((linkHref.startsWith("http:")
                                || linkHref.startsWith("https:"))
                                && !linkHref.contains("//localhost")
                                && !linkHref.contains("//127.0.0.1")
                                && !linkHref.contains("//[::1]")) {
                            result.computeIfAbsent(linkHref, k -> new TreeSet<Path>()).add(p);
                        }
                    }
                } catch (IOException e) {
                    throw new RuntimeException("Could not parse " + p, e);
                }
            });
        }
        return result.entrySet().parallelStream();
    }

    /**
     * Same as {@code invalidExternalLinks(new LinkValidator())}.
     *
     * @return a {@link Stream} of {@link ValidationError}s
     */
    public static Stream<ValidationError> invalidExternalLinks() {
        return invalidExternalLinks(new LinkValidator());
    }

    /**
     * @param validator a validator configured in a custom way
     * @return a {@link Stream} of {@link ValidationError}s
     */
    public static Stream<ValidationError> invalidExternalLinks(LinkValidator validator) {
        log.info("Validating external links");
        return externalLinks()
                .map(en -> {
                    final String uri = en.getKey();
                    final ValidationResult val = validator.validate(uri);
                    if (!val.isValid()) {
                        return new ValidationError(uri, val.message(), en.getValue());
                    } else {
                        return null;
                    }
                })
                .filter(e -> e != null);
    }

    /**
     * Same as {@code assertExternalLinksValid(predicate, SourceMapper.autodetect())}.
     *
     * @param ignore a predicate returning {@code true} for {@link ValidationError}s which should be ignored
     * @throws AssertionError in case there are link validation errors
     */
    public static void assertExternalLinksValid(Predicate<ValidationError> ignore) {
        assertExternalLinksValid(ignore, SourceMapper.autodetect());
    }

    /**
     * Collects invalid external links via {@link #invalidExternalLinks()}, filters the ignorable
     * {@link ValidationError}s away and throws an {@link AssertionError} in case there are some errors left.
     *
     * @param ignore a predicate returning {@code true} for {@link ValidationError}s which should be ignored
     * @param mapper a {@link SourceMapper} to use for mapping generated HTML files to their AsciiDoc sources
     * @throws AssertionError in case there are link validation errors
     */
    public static void assertExternalLinksValid(Predicate<ValidationError> ignore, SourceMapper mapper) {
        final Map<Path, List<ValidationError>> errors = new TreeMap<>();
        invalidExternalLinks()
                .filter(Predicate.not(ignore))
                .forEach(err -> {
                    for (Path p : err.paths()) {
                        errors.computeIfAbsent(p, k -> new ArrayList<>()).add(err);
                    }
                });
        final StringBuilder sb = new StringBuilder();
        for (Entry<Path, List<ValidationError>> en : errors.entrySet()) {
            final Path htmlPath = en.getKey();
            for (ValidationError err : en.getValue()) {
                SourceLocation sourceLoc = mapper.findSource(err.uri(), htmlPath);
                sb
                        .append("\n - ")
                        .append(sourceLoc);
                sb.append("\n     - ")
                        .append(err.uri())
                        .append("\n         - ")
                        .append(err.message());
            }
        }
        if (!sb.isEmpty()) {
            throw new AssertionError(sb.toString());
        }
    }

    private static Stream<Path> listFiles(Path path) {
        try {
            return Files.walk(path)
                    .filter(Files::isRegularFile)
                    .filter(p -> p.getFileName().toString().endsWith(".html"));
        } catch (IOException e) {
            throw new RuntimeException("Could not walk " + path, e);
        }
    }

}
